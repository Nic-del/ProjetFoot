<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Jeu de Foot avec Three.js</title>
  <style>
    body { margin: 0; }
    canvas { display: block; }
  </style>
</head>
<body>
  <script src="https://cdn.socket.io/4.7.5/socket.io.min.js" integrity="sha384-2huaZvOR9iDzHqslqwpR87isEmrfxqyWOF7hr7BY6KG0+hVKLoEXMPUJw3ynWuhO" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script>
    // Initialiser Socket.IO
    const socket = io("http://localhost:5000");

    // Initialiser la scène
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    const renderer = new THREE.WebGLRenderer();
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    // Ajouter le plan (terrain de foot)
    const planeGeometry = new THREE.PlaneGeometry(20, 10);
    const planeMaterial = new THREE.MeshBasicMaterial({ color: 0x00ff00 });
    const plane = new THREE.Mesh(planeGeometry, planeMaterial);
    plane.rotation.x = Math.PI / 2;
    scene.add(plane);

    // Liste des cubes joueurs et colliders
   const players = {};
   const colliders = {};

   function createPlayerCube(player) {
    const geometry = new THREE.BoxGeometry(1, 1, 1);
    const material = new THREE.MeshBasicMaterial({ color: player.color });
    const cube = new THREE.Mesh(geometry, material);
    cube.position.set(player.x, player.y, player.z);
    scene.add(cube);


    // Créer un collider (bounding box) pour ce cube 
    const collider = new THREE.Box3().setFromObject(cube);
    colliders[player.id] = collider;


    return cube;
  }
  
  socket.on('init', (serverPlayers) => {
    for (let id in serverPlayers) {
        players[id] = createPlayerCube(serverPlayers[id]);
    }
  });

  // Ajout d'un nouveau joueur
  socket.on('newPlayer', (player) => {
    players[player.id] = createPlayerCube(player);
  });

  socket.on('playerMoved', (player) => {
    if (players[player.id]) {
        players[player.id].position.set(player.x, player.y, player.z);


        // Mettre à jour le collider du joueur déplacé
        colliders[player.id].setFromObject(players[player.id]);
    }
  });

  socket.on('playerDisconnected', (id) => {
    if (players[id]) {
        scene.remove(players[id]);
        delete players[id];
        delete colliders[id]; // Supprimer également le collider
    }
  });

    // Ajouter une sphère (balle)
    const sphereGeometry = new THREE.SphereGeometry(0.5, 32, 32);
    const sphereMaterial = new THREE.MeshBasicMaterial({ color: 0xffff00 });
    const ball = new THREE.Mesh(sphereGeometry, sphereMaterial);
    ball.position.set(0, 0.5, 0);
    scene.add(ball);

    camera.position.set(0, 10, 15);
    camera.lookAt(0, 0, 0);
    // Ajouter deux cubes (joueurs)
    const cubeGeometry = new THREE.BoxGeometry(1, 1, 1);
    const player1Material = new THREE.MeshBasicMaterial({ color: 0xff0000 });
    const player2Material = new THREE.MeshBasicMaterial({ color: 0x0000ff });
    const player1 = new THREE.Mesh(cubeGeometry, player1Material);
    const player2 = new THREE.Mesh(cubeGeometry, player2Material);
    player1.position.set(-5, 0.5, 0);
    player2.position.set(5, 0.5, 0);
    scene.add(player1);
    scene.add(player2);
  
    camera.position.set(0, 10, 15);
    camera.lookAt(0, 0, 0);

    // Fonction de rendu
    function animate() {
      requestAnimationFrame(animate);
      renderer.render(scene, camera);
    }
    animate();

    // Gérer les mouvements avec les touches
    window.addEventListener('keydown', (event) => {
      switch (event.key) {
        case 'ArrowUp':
          player1.position.z -= 0.1;
          break;
        case 'ArrowDown':
          player1.position.z += 0.1;
          break;
        case 'ArrowLeft':
          player1.position.x -= 0.1;
          break;
        case 'ArrowRight':
          player1.position.x += 0.1;
          break;
      }
      // Envoyer la position mise à jour au serveur
      socket.emit('updatePosition', {
        player1: { x: player1.position.x, z: player1.position.z },
        player2: { x: player2.position.x, z: player2.position.z },
        ball: { x: ball.position.x, z: ball.position.z }
      });
    });

    // Recevoir la mise à jour de la position des autres clients
    socket.on('positionUpdate', (data) => {
      player1.position.x = data.player1.x;
      player1.position.z = data.player1.z;
      player2.position.x = data.player2.x;
      player2.position.z = data.player2.z;
      ball.position.x = data.ball.x;
      ball.position.z = data.ball.z;
    });
  </script>
</body>
</html>
