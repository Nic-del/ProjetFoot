<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Jeu de Foot avec Three.js</title>
  <style>
    body { margin: 0; }
    canvas { display: block; }
  </style>
</head>
<body>
<div id="container"></div>
<script src="https://cdn.socket.io/4.7.5/socket.io.min.js" integrity="sha384-2huaZvOR9iDzHqslqwpR87isEmrfxqyWOF7hr7BY6KG0+hVKLoEXMPUJw3ynWuhO" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script type="module">
  import { RGBELoader } from 'https://cdn.skypack.dev/three@0.136.0/examples/jsm/loaders/RGBELoader.js';
  import { DRACOLoader } from 'https://cdn.skypack.dev/three@0.136.0/examples/jsm/loaders/DRACOLoader.js';
  import { GLTFLoader } from 'https://cdn.skypack.dev/three@0.136.0/examples/jsm/loaders/GLTFLoader.js';
  const clock = new THREE.Clock();
  const STEPS_PER_FRAME = 5;

  // Initialiser Socket.IO
  const socket = io("http://localhost:5000");

  // Initialiser la scène
  const scene = new THREE.Scene();
  scene.background = new THREE.Color( 0x333333 );
  scene.environment = new RGBELoader().load( '/textures/venice_sunset_1k.hdr' );
  scene.environment.mapping = THREE.EquirectangularReflectionMapping;
  //scene.fog = new THREE.Fog( 0x333333, 10, 15 );

  // Initialiser la caméra
  const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight);
  // set default camera angle
  camera.rotation.x = 1.5;
  camera.rotation.y = 0;
  camera.rotation.z = 0;
  let radius = 10;  // Distance constante entre la caméra et le cube
  let angleX = 15;   // Variable pour l'angle en X (horizontal)
  let angleY = 0;   // Variable pour l'angle en Y (vertical)

  // Initialiser le rendu
  const renderer = new THREE.WebGLRenderer();
  renderer.setSize(window.innerWidth, window.innerHeight);

  // Ajouter le rendu à la page
  const container = document.getElementById('container');
  container.appendChild(renderer.domElement);

  // Variables pour stocker les mouvements de la souris
  let isPointerLocked = false;
  // default position of the mouse mouvement and the camera
  let mouseDeltaX = 0, mouseDeltaY = -1.3;

  const grid = new THREE.GridHelper( 200, 400, 0xffffff, 0xffffff );
  grid.material.opacity = 0.2;
  grid.material.depthWrite = false;
  grid.material.transparent = true;
  // set grid angle
  grid.rotation.x = Math.PI / 2;
  // set grid position
  grid.position.z = -0.5;
  // position of th
  scene.add( grid );

  // Car
  const carMaterial = new THREE.MeshPhysicalMaterial( {
    color: 0xff0000, metalness: 1.0, roughness: 0.5, clearcoat: 1.0, clearcoatRoughness: 0.03
  } );


  const detailsCarMaterial = new THREE.MeshStandardMaterial( {
    color: 0xffffff, metalness: 1.0, roughness: 0.5
  } );

  const glassCarMaterial = new THREE.MeshPhysicalMaterial( {
    color: 0xffffff, metalness: 0.25, roughness: 0, transmission: 1.0
  } );

  const shadow = new THREE.TextureLoader().load( 'models/gltf/ferrari_ao.png' );

  const dracoLoader = new DRACOLoader();
  dracoLoader.setDecoderPath( 'jsm/libs/draco/gltf/' );

  let carModel;  // Declare a variable to hold the car model

  const loader = new GLTFLoader();
  loader.setDRACOLoader( dracoLoader );

  loader.load( 'models/gltf/ferrari.glb', function ( gltf ) {

    carModel = gltf.scene.children[ 0 ];

    carModel.getObjectByName( 'body' ).material = carMaterial;

    carModel.getObjectByName( 'rim_fl' ).material = detailsCarMaterial;
    carModel.getObjectByName( 'rim_fr' ).material = detailsCarMaterial;
    carModel.getObjectByName( 'rim_rr' ).material = detailsCarMaterial;
    carModel.getObjectByName( 'rim_rl' ).material = detailsCarMaterial;
    carModel.getObjectByName( 'trim' ).material = detailsCarMaterial;

    carModel.getObjectByName( 'glass' ).material = glassCarMaterial;
    const wheels = [];
    wheels.push(
            carModel.getObjectByName( 'wheel_fl' ),
            carModel.getObjectByName( 'wheel_fr' ),
            carModel.getObjectByName( 'wheel_rl' ),
            carModel.getObjectByName( 'wheel_rr' )
    );

    // shadow
    const mesh = new THREE.Mesh(
            new THREE.PlaneGeometry( 0.655 * 4, 1.3 * 4 ),
            new THREE.MeshBasicMaterial( {
              map: shadow, blending: THREE.MultiplyBlending, toneMapped: false, transparent: true
            } )
    );
    mesh.rotation.x = - Math.PI / 2;
    mesh.renderOrder = 2;
    carModel.add( mesh );
    carModel.rotation.x = Math.PI / 2;
    carModel.position.z = -0.5;

    scene.add( carModel );

  } );

  // Fonction pour capturer le pointeur lors du clic
  document.body.addEventListener('click', () => {
    if (!isPointerLocked) {
      document.body.requestPointerLock();
    }
  });

  // Suivi de la capture du pointeur
  document.addEventListener('pointerlockchange', () => {
    isPointerLocked = document.pointerLockElement === document.body;
  });

  // Événement pour capturer les mouvements de la souris quand le pointeur est verrouillé
  document.addEventListener('mousemove', (event) => {
    if (isPointerLocked) {
      mouseDeltaX += event.movementX * 0.002;  // Ajuster la sensibilité pour l'axe X
      mouseDeltaY -= event.movementY * 0.002;  // Ajuster la sensibilité pour l'axe Y

      // Limiter l'angle vertical pour éviter que la caméra ne passe en dessous du terrain
      mouseDeltaY = THREE.MathUtils.clamp(mouseDeltaY, -Math.PI / 2, Math.PI / 2);
      mouseDeltaX = THREE.MathUtils.clamp(mouseDeltaX, -Math.PI / 2, Math.PI / 2);
    }
  });

  // Fonction d'animation
  function animate() {
    requestAnimationFrame(animate);


    if (carModel) {
      // Appliquer les mouvements de la souris à la caméra
      angleX = mouseDeltaX;
      angleY = mouseDeltaY;

      // Calculer la position de la caméra en coordonnées sphériques pour orbiter autour da la voiture
      camera.position.x = radius * Math.cos(angleY) * Math.sin(angleX);
      camera.position.y = radius * Math.sin(angleY);  // Déplacement vertical avec l'angle Y
      camera.position.z = radius * Math.cos(angleY) * Math.cos(angleX);

      camera.lookAt(carModel.position);  // Faire en sorte que la caméra regarde toujours la voiture
    }

    renderer.render(scene, camera);
  }

  animate();

  // Ajuster le rendu lors du redimensionnement de la fenêtre
  window.addEventListener('resize', () => {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
  });
</script>
</body>
</html>
