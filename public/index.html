<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Jeu de Foot avec Three.js</title>
  <style>
    body { margin: 0; }
    canvas { display: block; }
  </style>
</head>
<body>
  <script src="https://cdn.socket.io/4.7.5/socket.io.min.js" integrity="sha384-2huaZvOR9iDzHqslqwpR87isEmrfxqyWOF7hr7BY6KG0+hVKLoEXMPUJw3ynWuhO" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script>
    const heightPlane = 20;
    const widthPlane = 10;
    const sizeCube = 1;
    // Initialiser Socket.IO
    const socket = io("http://localhost:5000");

    // Initialiser la scène
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    const renderer = new THREE.WebGLRenderer();
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    const geometry = new THREE.PlaneGeometry( heightPlane, widthPlane );
    const material = new THREE.MeshBasicMaterial( {color: 0x00ff00} );
    const plane = new THREE.Mesh( geometry, material );
    plane.rotation.x = -Math.PI / 2;
    plane.position.y = -1; // Positionner le plan juste en dessous des cubes
    scene.add( plane );

    // Ajouter le plan (terrain de foot)
    /*const planeGeometry = new THREE.PlaneGeometry(20, 10);
    const planeMaterial = new THREE.MeshBasicMaterial({ color: 0xffff00 });
    const plane = new THREE.Mesh(planeGeometry, planeMaterial);
    plane.rotation.x = Math.PI / 2;
    scene.add(plane);*/

    // Liste des cubes joueurs et colliders
   const players = {};
   const colliders = {};

   function createPlayerCube(player) {
    const geometryCube = new THREE.BoxGeometry(sizeCube, sizeCube, sizeCube);
    const materialCube = new THREE.MeshBasicMaterial({ color: player.color });
    const cube = new THREE.Mesh(geometryCube, materialCube);
    cube.position.set(player.x, player.y, player.z);
    scene.add(cube);


    // Créer un collider (bounding box) pour ce cube 
    const collider = new THREE.Box3().setFromObject(cube);
    colliders[player.id] = collider;


    return cube;
  }
  
  socket.on('players', (serverPlayers) => {
    console.log(serverPlayers)
    for (let id in serverPlayers) {
      if (!players[id]) {
        players[id] = createPlayerCube(serverPlayers[id]);
      }
    }
  });

  // Ajout d'un nouveau joueur
  socket.on('newPlayer', (data) => {
    console.log(data)
    players[data.player.id] = createPlayerCube(data.player);
  });

    // Ajouter une sphère (balle)
    const sphereGeometry = new THREE.SphereGeometry(0.5, 32, 32);
    const sphereMaterial = new THREE.MeshBasicMaterial({ color: 0xffff00 });
    const ball = new THREE.Mesh(sphereGeometry, sphereMaterial);
    ball.position.set(0, 0.5, 0);
    scene.add(ball);

    camera.position.set(0, 0, 0);
    camera.lookAt(0, 0, 0);
    // Ajouter deux cubes (joueurs)
    /*const cubeGeometry = new THREE.BoxGeometry(1, 1, 1);
    const player1Material = new THREE.MeshBasicMaterial({ color: 0xff0000 });
    const player2Material = new THREE.MeshBasicMaterial({ color: 0x0000ff });
    const player1 = new THREE.Mesh(cubeGeometry, player1Material);
    const player2 = new THREE.Mesh(cubeGeometry, player2Material);
    player1.position.set(-5, 0.5, 0);
    player2.position.set(5, 0.5, 0);
    scene.add(player1);
    scene.add(player2);*/
  
    camera.position.set(0, 10, 15);
    camera.lookAt(0, 0, 0);

    // Fonction de rendu
    function animate() {
      requestAnimationFrame(animate);
      renderer.render(scene, camera);
    }
    animate();

    // Recevoir la mise à jour de la position des autres clients
    socket.on('positionUpdate', (data) => {
      player1.position.x = data.player1.x;
      player1.position.z = data.player1.z;
      player2.position.x = data.player2.x;
      player2.position.z = data.player2.z;
      ball.position.x = data.ball.x;
      ball.position.z = data.ball.z;
    });


    // Mise à jour de la position des joueurs
    socket.on('playerMoved', (player) => {
      if (players[player.id]) {
        players[player.id].position.set(player.x, player.y, player.z);
        colliders[player.id].setFromObject(players[player.id]);
      }
    });

    // Suppression d'un joueur déconnecté
    socket.on('playerDisconnected', (id) => {
      if (players[id]) {
        scene.remove(players[id]);
        delete players[id];
        delete colliders[id];
      }
    });

    // Contrôle du joueur local (utilisation des touches de direction)
    const moveSpeed = 0.1;
    document.addEventListener('keydown', (event) => {
      const player = players[socket.id];
      if (player) {
        let prevPosition = player.position.clone(); // Stocker l'ancienne position

        if (event.key === 'ArrowUp' && player.position.z - moveSpeed > (-widthPlane/2 + sizeCube)) player.position.z -= moveSpeed;
        if (event.key === 'ArrowDown' && player.position.z + moveSpeed < widthPlane/2) player.position.z += moveSpeed;
        if (event.key === 'ArrowLeft' && player.position.x - moveSpeed > (-heightPlane/2 + sizeCube)) player.position.x -= moveSpeed;
        if (event.key === 'ArrowRight' && player.position.x + moveSpeed < (heightPlane/2 - sizeCube)) player.position.x += moveSpeed;

        // Mettre à jour le collider du joueur
        colliders[socket.id].setFromObject(player);

// Vérifier les collisions avec les autres joueurs
        let collisionDetected = false;
        for (let id in colliders) {
          if (id !== socket.id && colliders[socket.id].intersectsBox(colliders[id])) {
            collisionDetected = true;
            break;
          }
        }


        // Si collision, annuler le mouvement
        if (collisionDetected) {
          player.position.copy(prevPosition);
        } else {
          // Envoi des nouvelles positions au serveur uniquement si pas de collision
          socket.emit('move', { x: player.position.x, z: player.position.z });
        }
      }
    });
  </script>
</body>
</html>
